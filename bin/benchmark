#!/usr/bin/env ruby

# frozen_string_literal: true

require 'bundler/setup'
require 'benchmark/ips'
require 'tempfile'
require 'stringio'

# from benchmark/ips readme
class GCSuite
  def warming(*) # leftovers:allow
    run_gc
  end

  def running(*) # leftovers:allow
    run_gc
  end

  def warmup_stats(*); end # leftovers:allow

  def add_report(*); end # leftovers:allow

  private

  def run_gc
    GC.enable
    GC.start
    GC.disable
  end
end

GC.disable

config = { suite: GCSuite.new }

def benchmark(label)
  return unless ARGV.empty? || ARGV.include?(label)

  puts "\n#{label}:"

  yield
  puts ''
end

benchmark('or-or-any') do
  Benchmark.ips do |x|
    x.config(config)
    @miss_array = [nil, nil]
    @second_array = [nil, 1]
    @first_array = [1, nil]
    @miss = nil
    @hit = 1

    x.report(:any_first) { @first_array.any? { |x| x } }
    x.report(:any_second) { @second_array.any? { |x| x } }
    x.report(:any_none) { @miss_array.any? { |x| x } }
    x.report(:or_first) { @hit || @miss }
    x.report(:or_second) { @miss || @hit }
    x.report(:or_none) { @miss || @miss }
    x.compare!
  end
end

benchmark('enumerate-array') do
  Benchmark.ips do |x|
    x.config(config)
    @array = (0..1000).to_a

    x.report(:each) { @array.each { |x| x } }
    x.report(:reverse_each) { @array.reverse_each { |x| x } }
    x.report(:'each.each') { @array.each.each { |x| x } }
    x.compare!
  end
end

benchmark('enumerate-array-proc') do
  Benchmark.ips do |x|
    x.config(config)
    @array = (0..1000).to_a

    x.report(:each) { @array.each(&:itself) }
    x.report(:reverse_each) { @array.reverse_each(&:itself) }
    x.report(:'each.each') { @array.each.each(&:itself) }
    x.compare!
  end
end

benchmark('array-index-offset') do
  Benchmark.ips do |x|
    x.config(config)
    @array = (0..1000).to_a

    x.report(:small_index_zero_offset_no_drop) { @array.index(3) }
    x.report(:small_index_zero_offset_drop) { @array.drop(0).index(3) }
    x.report(:small_index_zero_offset_with_index) { @array.index.with_index { |item, index| index > 0 && item == 3 } }

    x.report(:large_index_zero_offset_no_drop) { @array.index(900) }
    x.report(:large_index_zero_offset_drop) { @array.drop(0).index(900) }
    x.report(:large_index_zero_offset_with_index) { @array.index.with_index { |item, index| index > 0 && item == 900 } }

    x.report(:small_index_small_offset_drop) { @array.drop(2).index(3) + 2 }
    x.report(:small_index_small_offset_with_index) { @array.index.with_index { |item, index| index > 2 && item == 3 } }

    x.report(:large_index_small_offset_drop) { @array.drop(2).index(990) + 2 }
    x.report(:large_index_small_offset_with_index) { @array.index.with_index { |item, index| index > 2 && item == 990 } }

    x.report(:large_index_large_offset_drop) { @array.drop(900).index(990) + 900 }
    x.report(:large_index_large_offset_with_index) { @array.index.with_index { |item, index| index > 900 && item == 990 } }
    x.compare!
  end
end


benchmark('bsearch-or-include') do
  Benchmark.ips do |x|
    x.config(config)
    require_relative '../lib/path_list'
    @array = ('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'..'aaaaaaaaaaaaaaaaaaaaaaaaaaazzz').to_a[0..8]
    @re  = PathList::RegexpBuilder.new({ start_anchor: PathList::RegexpBuilder::Merge.merge(@array.map { |item| item.split('').reverse_each.reduce({ end_anchor: nil }) { |a, e| { e => a } } })}).to_regexp
    @reB = PathList::RegexpBuilder.new({ start_anchor: PathList::RegexpBuilder::Merge.merge(@array.map { |item| item.split('').reverse_each.reduce({ end_anchor: nil }) { |a, e| { e => a } } })}).to_regexp_b
      puts @re
    puts @reB
    # x.report(:bsearch_hit) { @array.each { |target| target += ''; @array.bsearch {|e| target <=> e } } }
    # x.report(:bsearch_miss) { @array.each { |target| target += '1'; @array.bsearch {|e| target <=> e } } }

    # x.report(:include_hit) { @array.each { |target| target += ''; @array.include?(target) } }
    # x.report(:include_miss) { @array.each { |target| target += '1'; @array.include?(target) } }
    x.report(:reB_hit) { @array.each { |target| target += ''; @reB.match?(target) } }
    x.report(:reB_miss) { @array.each { |target| target += '1'; @reB.match?(target) } }

    x.report(:re_hit) { @array.each { |target| target += ''; @re.match?(target) } }
    x.report(:re_miss) { @array.each { |target| target += '1'; @re.match?(target) } }

    x.compare!
  end
end
